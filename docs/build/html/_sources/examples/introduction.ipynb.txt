{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "9faebe6e",
   "metadata": {},
   "source": [
    "# Introduction to NoisyCircuits\n",
    "\n",
    "## Library Imports"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "27c4ee30",
   "metadata": {},
   "outputs": [],
   "source": [
    "from NoisyCircuits import QuantumCircuit as QC\n",
    "from NoisyCircuits.utils.GetNoiseModel import GetNoiseModel\n",
    "import pickle\n",
    "import os\n",
    "import json\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2f419653",
   "metadata": {},
   "source": [
    "## Setup Input Fields\n",
    "\n",
    "In the input fields:\n",
    "\n",
    "1. **token:** refers to the IBM API token for accessing IBM Quantum Systems. See IBM Documentation for account creation and token access [here](https://quantum.cloud.ibm.com/docs/en/guides/cloud-setup).\n",
    "2. **backend_name:** refers to the IBM quantum hardware for which the noise model needs to be built. Currently, the software only supports the IBM Eagle R3 Chip set which have a basis gate set comprising of $X$, $\\sqrt{X}$, $R_z(\\cdot)$ and $ECR$. As of 15.08.2025, the backend codenamed \"ibm_brisbane\" is the only available quantum hardware with the Eagle R3 chip.\n",
    "3. **num_qubits:** the number of qubits in the quantum circuits.\n",
    "4. **num_cores:** the number of cores to run parallel Monte-Carlo Wavefunction (MCWF) Trajectories. (Ensure sufficient resources are available for runs.)\n",
    "5. **num_trajectories:** the number of trajectories for the MCWF method.\n",
    "6. **threshold:** the threshold for filtering out noise data.\n",
    "7. **jsonize:** a boolean variable indicating whether the noise model needs to be jsonized or if the input noise model is already in a json format."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "5ad90c5b",
   "metadata": {},
   "outputs": [],
   "source": [
    "token = json.load(open(os.path.join(os.path.expanduser(\"~\"), \"ibm_api.json\"), \"r\"))[\"apikey\"] # Replace with your IBM Quantum token\n",
    "backend_name = \"ibm_fez\"\n",
    "num_qubits = 2\n",
    "num_cores = 10\n",
    "num_trajectories = 20\n",
    "threshold = 1e-4\n",
    "jsonize = True\n",
    "verbose = True\n",
    "# Options: \"heron\", \"eagle\". Note that \"eagle\" is now deprecated and only available in simulation mode (i.e., no noise model from hardware).\n",
    "qpu_type = \"heron\" "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c6e6835c",
   "metadata": {},
   "source": [
    "### Getting the Noise Model\n",
    "\n",
    "Run the code below to obtain the noise model from IBM backend calibration data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1bcfeea6",
   "metadata": {},
   "outputs": [],
   "source": [
    "noise_model = GetNoiseModel(backend_name=backend_name, token=token).get_noise_model()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a0e78e03",
   "metadata": {},
   "source": [
    "Run the code below to use a sample noise model generated from IBM calibration data."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "37ea9f44",
   "metadata": {},
   "outputs": [],
   "source": [
    "if qpu_type == \"eagle\":\n",
    "    noise_model = pickle.load(open(\"../noise_models/Noise_Model_Eagle_QPU.pkl\", \"rb\"))\n",
    "elif qpu_type == \"heron\":\n",
    "    noise_model = pickle.load(open(\"../noise_models/Noise_Model_Heron_QPU.pkl\", \"rb\"))\n",
    "else:\n",
    "    raise ValueError(\"Invalid qpu_type. Choose either 'heron' or 'eagle'.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "edb84673",
   "metadata": {},
   "source": [
    "### Initialize the Circuit Instance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "53afe932",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Available qubits in roerror_map: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155]\n",
      "Requested qubits: [0, 1]\n",
      "Completed Extraction of Measurement Errors.\n",
      "Completed Extraction of two-qubit gate Errors.\n",
      "Starting post-processing on Single Qubit Errors.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Successfully switched backend to qulacs.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Completed post-processing on Single Qubit Errors.\n",
      "Processing two-qubit gate errors.\n",
      "Qubit pair (0, 1): 18/48 errors above threshold (30 filtered out)\n",
      "Qubit pair (1, 0): 18/48 errors above threshold (30 filtered out)\n",
      "Two Qubit Gate errors processed.\n",
      "Building Noise Operators for Two Qubit Gate Errors.\n",
      "Completed building Noise Operators for Two Qubit Gate Errors.\n",
      "Extracting Measurement Errors.\n",
      "Preparing Qubit Connectivity Map for Requested Qubits\n",
      "Qubit Connectivity Map Prepared.\n",
      "Returning Single Qubit Error Instructions, Two Qubit Gate Error Instructions, Measurement Errors and Connectivity Map.\n",
      "2026-02-17 14:30:21,074\tINFO worker.py:1927 -- Started a local Ray instance.\n"
     ]
    }
   ],
   "source": [
    "nqc = QC(num_qubits=num_qubits, \n",
    "         noise_model=noise_model, \n",
    "         num_cores=num_cores,\n",
    "         backend_qpu_type=\"heron\", \n",
    "         num_trajectories=num_trajectories, \n",
    "         sim_backend=\"qulacs\",\n",
    "         threshold=threshold, \n",
    "         jsonize=jsonize,\n",
    "         verbose=verbose)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "86e23d6f",
   "metadata": {},
   "source": [
    "## Example Circuit\n",
    "\n",
    "### Example 1: Creating an EPR Pair\n",
    "\n",
    "First we create an EPR pair generating quantum circuit and execute it as a pure statevector simulation and as a noisy simulation (comparing density matrix and MCWF methods)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "e69d7a85",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Reset the circuit --> Ensure the circuit tape has no prior instructions\n",
    "nqc.refresh()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "bb3126a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create the EPR Pair Circuit\n",
    "nqc.H(0)\n",
    "nqc.CX(0, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b3c20237",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([5.00000000e-01, 3.39184123e-33, 3.39184123e-33, 5.00000000e-01])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Run the circuit with pure state simulation, argument qubits is the measured qubits\n",
    "nqc.run_pure_state(qubits=[0,1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "0cf21b5a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.47978989, 0.02075711, 0.02045535, 0.47899765])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Run the circuit with density matrix simulation\n",
    "nqc.run_with_density_matrix(qubits=[0,1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "57643bd0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.4828629 , 0.01725612, 0.01725288, 0.4826281 ])"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Run with MCWF Simulation\n",
    "nqc.execute(qubits=[0,1], num_trajectories=100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "58366c3a",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.48053472, 0.01958415, 0.01957976, 0.48030137])"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Run with MCWF Simulation\n",
    "nqc.execute(qubits=[0,1], num_trajectories=1000)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e12bb847",
   "metadata": {},
   "source": [
    "For the MCWF method, using more trajectories ensures better convergence to the density matrix result."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "166fab99",
   "metadata": {},
   "source": [
    "### Example 2: Qubit Swap\n",
    "\n",
    "In this example, we see the effect of noise on a qubit swap between two qubits whose states where initialized using angle encoding."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "c2a46bc0",
   "metadata": {},
   "outputs": [],
   "source": [
    "# nqc.refresh() resets the quantum circuit to zero gates.\n",
    "# The argument to the rotation gates are the angle, followed by the qubit index.\n",
    "nqc.refresh()\n",
    "nqc.RY(theta=1.2, qubit=0)\n",
    "nqc.RY(theta=0.5, qubit=1)\n",
    "nqc.SWAP(qubit1=0, qubit2=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "5e00d991",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.68117888, 0.31882112])"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Run with pure state simulation\n",
    "nqc.run_pure_state(qubits=[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "48c58a3d",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.66539623, 0.33460377])"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Run with the density matrix simulation\n",
    "nqc.run_with_density_matrix(qubits=[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "29b1f8a5",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.66282392, 0.33717608])"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Run with MCWF Simulation\n",
    "nqc.execute(qubits=[1], num_trajectories=500)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1f01cf1a",
   "metadata": {},
   "source": [
    "## Shutdown the Parallel instance\n",
    "\n",
    "Due to parallel implementation with \"ray\", there is a requirement to explicitly shutdown the parallel pool"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "901b6883",
   "metadata": {},
   "outputs": [],
   "source": [
    "nqc.shutdown()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "NoisyCircuits",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.14"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
